/*
* На вход подается 16-битное число period и флаг сброса часов reset.

* У чипа два выхода:
* 1. ticks (0 ≤ ticks < period) — сколько тиков прошло с начала периода,
* 2. loop — равен единице, когда ticks равен нулю.
* 
* Если предыдущее значение ticks оказывается за пределами корректных 
* значений (из-за уменьшения period), нужно вернуть ticks=0, loop=1
*/
CHIP Clock {
    IN period[16], reset;
    OUT ticks[16], loop;

    PARTS:
    // ------------------- Начало итерации счётчика -------------------

    // Увеличиваем счётчик на +1 или же +такт
    Inc16(in=ticksNow, out=ticksNext);

    // Проверяем больше ли значения счётчика чем у period. Если period = ticks, то 11..11
    Not16(in=ticksNext, out=notTicksNext);
    Add16(a=period, b=notTicksNext, out=deltaTicks, out[15]=negativeDelta);

    // Проверка нужно ли сбрасывать счётчик
    Not(in=negativeDelta, out=notNegativeDelta);
    Not(in=reset, out=notReset);
    And(a=notReset, b=notNegativeDelta, out=needToContinue);

    // Если счётчик нужно сбросить, возвращаем 0
    Mux16(a=false, b=ticksNext, sel=needToContinue, out=newTicks);

    // Запоминаем, будет ли счётчик в следующем такте начинаиться с 0
    DFF(in=negativeDelta, out=wasOverflow);
    DFF(in=reset, out=wasReset);
    Or(a=wasOverflow, b=wasReset, out=loop);

    // Возвращаем итоговое значение счётчика и зацикливаем цикл
    Register(in=newTicks, load=true, out=ticks, out=ticksNow);

}


/*
CHIP Clock {
    IN period[16], reset;
    OUT ticks[16], loop;

    PARTS:
    Inc16(in=a, out=b);
    Not16(in=b, out=c);
    Add16(a=period, b=c, out=d, out[15]=e);
    Or(a=e, b=reset, out=f);
    Mux16(a=b, b=false, sel=f, out=g);
    DFF(in=f, out=loop);
    Register(in=g, load=true, out=ticks, out=a);
}
*/
